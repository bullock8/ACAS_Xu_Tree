from ACAS_Xu_networks.acas_xu_nets import *
'''
From Stanley Bak's ACAS Xu repository
'''

def load_trees():
    
    tree_list = []
    for i in range(0, 5):
        tree_object = pickle.load(open(f'saved_trees{os.sep}tree_{i}.pickle', 'rb'))
        tree_list.append(tree_object)
    
    return tree_list

def get_tree_cmd(prev_cmd, tree_list, state_vec):
    '''
    input:
        tree_list:  a list of the five different DecisionTreeClassifier objects
        state_vec:  the 5-state vector for the ACAS Xu input    
    output:
        turn_cmd:  an integer, from 0 to 4 inclusive, specifying the ACAS Xu turn command
            
    '''
    acas_tree = tree_list[prev_cmd]
    
    state_npy = np.array(state_vec).reshape((1,5))
    
    turn_cmd = int(acas_tree.predict(state_npy))
    return turn_cmd


def main():
    'main entry point'

    # parse arguments
    parser = argparse.ArgumentParser(description='Run ACASXU Dubins model simulator.')
    parser.add_argument("--save-mp4", action='store_true', default=False, help="Save plotted mp4 files to disk.")
    parser.add_argument("--intruder-turn", action='store_true', default=False, help="Toggles boolean flag to allow intruder to perform \
                                                                                     commands other than flying straight.")
    parser.add_argument("--fixed-seed", type=int, default=None, help="Simulates the parameters generated by provided seed.")
    args = parser.parse_args()

    intruder_can_turn = args.intruder_turn
    save_mp4 = args.save_mp4
    fixed_seed = args.fixed_seed

    interesting_seed = -1
    interesting_state = None
    
    tree_list = load_trees()

    if fixed_seed is not None:
        interesting_seed = fixed_seed
    else:
        num_sims = 10000
        # with 10000 sims, seed 671 has min_dist 4254.5ft

        start = time.perf_counter()

        for seed in range(num_sims):
            if seed % 1000 == 0:
                print(f"{(seed//1000) % 10}", end='', flush=True)
            elif seed % 100 == 0:
                print(".", end='', flush=True)

            init_vec, cmd_list, init_velo = make_random_input(seed, intruder_can_turn=intruder_can_turn)

            v_own = init_velo[0]
            v_int = init_velo[1]

            # reject start states where initial command is not clear-of-conflict
            state5 = state7_to_state5(init_vec, v_own, v_int)

            if state5[0] > 60760:
                command = 0 # rho exceeds network limit
            else:
                prev_cmd = 0#State.nets[0]
                command = get_tree_cmd(prev_cmd, tree_list, state5)
                #res = run_network(State.nets[0], state5)
                #command = np.argmin(res)

            if command != 0:
                continue

            # run the simulation
            s = State(init_vec, v_own, v_int, save_states=False)
            s.simulate(cmd_list, tree_list)

            # save most interesting state based on some criteria
            if interesting_state is None or s.min_dist < interesting_state.min_dist:
                interesting_seed = seed
                interesting_state = s

        diff = time.perf_counter() - start
        ms_per_sim = round(1000 * diff / num_sims, 3)
        print(f"\nDid {num_sims} sims in {round(diff, 1)} secs ({ms_per_sim}ms per sim)")

    # optional: do plot
    assert interesting_seed != -1

    init_vec, cmd_list, init_velo = make_random_input(interesting_seed, intruder_can_turn=intruder_can_turn)
    s = State(init_vec, init_velo[0], init_velo[1], save_states=True)
    s.simulate(cmd_list, tree_list)

    d = round(s.min_dist, 2)
    print(f"\nSeed {interesting_seed} has min_dist {d}ft")
    plot(s, save_mp4)

if __name__ == "__main__":
    main()